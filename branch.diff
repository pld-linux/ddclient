# Revision 122
Index: release/readme.txt
===================================================================

Property changes on: release
___________________________________________________________________
Added: svn:ignore
   + ddclient-*


Index: sample-etc_ddclient.conf
===================================================================
--- sample-etc_ddclient.conf	(.../tags/release-3.8.0)
+++ sample-etc_ddclient.conf	(.../trunk)
@@ -50,6 +50,10 @@
 #use=fw, fw=192.168.1.254/status.htm, fw-skip='IP Address' # found after IP Address
 #
 ## To obtain an IP address from Web status page (using the proxy if defined)
+## by default, checkip.dyndns.org is used if you use the dyndns protocol. 
+## Using use=web is enough to get it working.
+## WARNING: set deamon at least to 600 seconds if you use checkip or you could
+## get banned from their service.
 #use=web, web=checkip.dyndns.org/, web-skip='IP Address' # found after IP Address
 #
 #use=ip,                     ip=127.0.0.1	# via static IP's
@@ -160,3 +164,17 @@
 # login=my-namecheap.com-login,			\
 # password=my-namecheap.com-password		\
 # myhost.namecheap.com 
+
+##
+##
+## Loopia (loopia.se)
+##
+# use=web
+# web=loopia
+# protocol=dyndns2
+# server=dns.loopia.se
+# script=/XDynDNSServer/XDynDNS.php
+# login=my-loopia.se-login
+# password=my-loopia.se-password
+# my.domain.tld,other.domain.tld
+
Index: ddclient
===================================================================
--- ddclient	(.../tags/release-3.8.0)
+++ ddclient	(.../trunk)
@@ -20,7 +20,9 @@
 use Sys::Hostname;
 use IO::Socket;
 
-my $version  = "3.8.0";
+my ($VERSION) = q$Revision$ =~ /(\d+)/;
+
+my $version  = "3.8.0-r". $VERSION;
 my $programd  = $0; 
 $programd =~ s%^.*/%%;
 my $program   = $programd;
@@ -63,6 +65,7 @@
    'dyndns'       => { 'url' => 'http://checkip.dyndns.org/', 'skip' =>
    'Current IP Address:', },
    'dnspark'      => { 'url' => 'http://ipdetect.dnspark.com/', 'skip' => 'Current Address:', },
+   'loopia'       => { 'url' => 'http://dns.loopia.se/checkip/checkip.php', 'skip' => 'Current Address:', },
 );
 my %builtinfw = (
     'watchguard-soho'        => {
@@ -283,6 +286,7 @@
      'if'                     => ": obtain IP from the -if {interface}",
      'cmd'                    => ": obtain IP from the -cmd {external-command}",
      'cisco'                  => ": obtain IP from Cisco FW at the -fw {address}",
+     'cisco-asa'              => ": obtain IP from Cisco ASA at the -fw {address}",
      map { $_ => sprintf ": obtain IP from %s at the -fw {address}", $builtinfw{$_}->{'name'} } keys %builtinfw,
 );
 sub ip_strategies_usage {
@@ -292,6 +296,7 @@
 my %web_strategies = (
 	'dyndns'=> 1,
 	'dnspark'=> 1,
+	'loopia'=> 1,
 );
 
 sub setv {
@@ -307,6 +312,7 @@
 my %variables = (
     'global-defaults'    => {
 	'daemon'              => setv(T_DELAY, 0, 0, 1, 0,                    interval('60s')),
+	'foreground'          => setv(T_BOOL,  0, 0, 1, 0,                    undef),
 	'file'                => setv(T_FILE,  0, 0, 1, "$etc$program.conf",  undef),
 	'cache'               => setv(T_FILE,  0, 0, 1, "$cachedir$program.cache", undef),
 	'pid'                 => setv(T_FILE,  0, 0, 1, "",                   undef),
@@ -428,6 +434,7 @@
 	'examples'   => \&nic_dyndns2_examples,
 	'variables'  => merge(
 			  { 'custom'  => setv(T_BOOL,   0, 1, 1, 0, undef),	},
+			  { 'script'  => setv(T_STRING, 1, 1, 1, '/nic/update', undef),	},
 #			  { 'offline' => setv(T_BOOL,   0, 1, 1, 0, undef),	},
 			  $variables{'dyndns-common-defaults'},
 			  $variables{'service-common-defaults'},
@@ -524,6 +531,16 @@
                           $variables{'service-common-defaults'},
                         ),
     },
+    'freedns' => {
+        'updateable' => undef,
+        'update'     => \&nic_freedns_update,
+        'examples'   => \&nic_freedns_examples,
+        'variables'  => merge(
+			  { 'server'       => setv(T_FQDNP,  1, 0, 1, 'freedns.afraid.org',    undef)    },
+			  { 'min-interval' => setv(T_DELAY,  0, 0, 1, 0, interval('5m')),},
+			  $variables{'service-common-defaults'},
+			),
+    },
 );
 $variables{'merged'} = merge($variables{'global-defaults'},
 			     $variables{'service-common-defaults'},
@@ -535,6 +552,7 @@
     "usage: ${program} [options]",
     "options are:",
     [ "daemon",      "=s", "-daemon delay         : run as a daemon, specify delay as an interval." ],
++     [ "foreground",  "!",  "-foreground           : do not fork" ],
     [ "proxy",       "=s", "-proxy host           : use 'host' as the HTTP proxy" ],
     [ "server",      "=s", "-server host          : update DNS information on 'host'" ],
     [ "protocol",    "=s", "-protocol type        : update protocol used" ],
@@ -623,7 +641,10 @@
 $SIG{'HUP'}    = sub { $caught_hup  = 1; };
 $SIG{'TERM'}   = sub { $caught_term = 1; };
 $SIG{'KILL'}   = sub { $caught_kill = 1; };
-if (opt('daemon') && !opt('force')) {
+# don't fork() if foreground or force is on
+if (opt('foreground') || opt('force')) {
+    ;
+} elsif (opt('daemon')) {
     $SIG{'CHLD'}   = 'IGNORE';
     my $pid = fork;
     if ($pid < 0) {
@@ -633,12 +654,15 @@
 	exit 0;
     }
     $SIG{'CHLD'}   = 'DEFAULT';
-    $opt{'syslog'} = 1;
     open(STDOUT, ">/dev/null");
     open(STDERR, ">/dev/null");
     open(STDIN,  "</dev/null");
+}
 
+# write out the pid file if we're daemon'ized
+if(opt('daemon')) { 
     write_pid();
+    $opt{'syslog'} = 1;
 }
 
 umask 077;
@@ -716,47 +740,58 @@
 ## update_nics
 ######################################################################
 sub update_nics {
-    my %examined = ();
+	my %examined = ();
+	my %iplist = ();
 
-    foreach my $s (sort keys %services) {
-	my (@hosts, %ips) = ();
-	my $updateable = $services{$s}{'updateable'};
-	my $update     = $services{$s}{'update'};
+	foreach my $s (sort keys %services) {
+		my (@hosts, %ips) = ();
+		my $updateable = $services{$s}{'updateable'};
+		my $update     = $services{$s}{'update'};
 
+		foreach my $h (sort keys %config) {
+			next if $config{$h}{'protocol'} ne lc($s);
+			$examined{$h} = 1;
+			my $use = $config{$h}{'use'} || opt('use');
+			local $opt{$use} = $config{$h}{$use} if $config{$h}{$use};
+			# bug #13: we should only do this once
+			# use isn't enough, we have to save the origin to.
+			# this will break the multiple ip stuff if use has 
+			# been used twice for the same device.
+			my $ip = "";
+			if (defined $iplist{$use}) {
+				$ip = $iplist{$use};
+			} else {
+				$ip = get_ip($use, $h);
+				if (!defined $ip || !$ip) {
+					warning("unable to determine IP address")
+						if !$daemon || opt('verbose');
+					next;
+				}
+				if ($ip !~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/) {
+					warning("malformed IP address (%s)", $ip);
+					next;
+				}
+				$iplist{$use} = $ip;
+			}
+			$config{$h}{'wantip'} = $ip;
+			next if !nic_updateable($h, $updateable);
+			push @hosts, $h;
+			$ips{$ip} = $h;
+		}
+		if (@hosts) {
+			$0 = sprintf("%s - updating %s", $program, join(',', @hosts));
+			&$update(@hosts);
+			runpostscript(join ' ', keys %ips);
+		}
+	}
 	foreach my $h (sort keys %config) {
-	    next if $config{$h}{'protocol'} ne lc($s);
-	    $examined{$h} = 1;
-	    my $use = $config{$h}{'use'} || opt('use');
-	    local $opt{$use} = $config{$h}{$use} if $config{$h}{$use};
-	    my $ip = get_ip($use);
-	    if (!defined $ip || !$ip) {
-		warning("unable to determine IP address")
-		    if !$daemon || opt('verbose');
-		next;
-	    }
-	    if ($ip !~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/) {
-		warning("malformed IP address (%s)", $ip);
-		next;
-	    }
-	    $config{$h}{'wantip'} = $ip;
-	    next if !nic_updateable($h, $updateable);
-	    push @hosts, $h;
-	    $ips{$ip} = $h;
+		if (!exists $examined{$h}) {
+			failed("%s was not updated because protocol %s is not supported.", 
+					$h, define($config{$h}{'protocol'}, '<undefined>')
+				  );
+		}
 	}
-	if (@hosts) {
-            $0 = sprintf("%s - updating %s", $program, join(',', @hosts));
-	    &$update(@hosts);
-	    runpostscript(join ' ', keys %ips);
-	}
-    }
-    foreach my $h (sort keys %config) {
-	if (!exists $examined{$h}) {
-	    failed("%s was not updated because protocol %s is not supported.", 
-		$h, define($config{$h}{'protocol'}, '<undefined>')
-	    );
-	}
-    }
-    write_cache(opt('cache'));
+	write_cache(opt('cache'));
 }
 ######################################################################
 ## unlink_pid()
@@ -841,9 +876,9 @@
 	%opt   = %saved;
 
 	foreach my $h (keys %cache) {
-	    if (exists $config{$h}) {
+	    if (exists $config->{$h}) {
 		foreach (qw(atime mtime wtime ip status)) {
-	    	    $config{$h}{$_} = $cache{$h}{$_} if exists $cache{$h}{$_};
+	    	    $config->{$h}{$_} = $cache{$h}{$_} if exists $cache{$h}{$_};
 		}
 	    }
 	}
@@ -1055,7 +1090,7 @@
     $opt{'use'} = 'web' if !define($opt{'use'}) && defined($opt{'web'});
 
     ## sanity check
-    $opt{'max-interval'}       = max(interval(opt('max-interval')), interval(default('max-interval')));
+    $opt{'max-interval'}       = min(interval(opt('max-interval')), interval(default('max-interval')));
     $opt{'min-interval'}       = max(interval(opt('min-interval')), interval(default('min-interval')));
     $opt{'min-error-interval'} = max(interval(opt('min-error-interval')), interval(default('min-error-interval')));
 
@@ -1093,7 +1128,7 @@
 	## merge options into host definitions or globals
 	if (@hosts) {
 	    foreach my $h (@hosts) {
-		$config{$h} = %{ merge(\%options, $config{$h}) };
+		$config{$h} = merge(\%options, $config{$h});
 	    }
 	    $opt{'host'} = join(',', @hosts);
 	} else {
@@ -1157,6 +1192,8 @@
 	$proto = $config{$h}{'protocol'};
 	$proto = opt('protocol')          if !defined($proto);
 
+	load_sha1_support() if ($proto eq "freedns");
+
  	if (!exists($services{$proto})) {
 	    warning("skipping host: %s: unrecognized protocol '%s'", $h, $proto);
 	    delete $config{$h};
@@ -1481,6 +1518,8 @@
 }
 sub opt {
     my $v = shift;
+    my $h = shift;
+    return $config{$h}{$v}   if defined($h && $config{$h}{$v});
     return $opt{$v} 	if defined $opt{$v};
     return $globals{$v}	if defined $globals{$v};
     return default($v)  if defined default($v);
@@ -1696,11 +1735,6 @@
     # fix padding at the end
     my $padding = (3 - length($_[0]) % 3) % 3;
     $res =~ s/.{$padding}$/'=' x $padding/e if $padding;
-
-    # break encoded string into lines of no more than 76 characters each
-    if (length $eol) {
-        $res =~ s/(.{1,76})/$1$eol/g;
-    }
     $res;
 }
 ######################################################################
@@ -1712,12 +1746,26 @@
         fatal(<<"EOM");
 Error loading the Perl module IO::Socket::SSL needed for SSL connect.
 On Debian, the package libio-socket-ssl-perl must be installed.
+On Red Hat, the package perl-IO-Socket-SSL must be installed.
 EOM
     }
     import  IO::Socket::SSL;
     { no warnings; $IO::Socket::SSL::DEBUG = 0; }
 }
 ######################################################################
+## load_sha1_support
+######################################################################
+sub load_sha1_support {
+    my $sha1_loaded = eval {require Digest::SHA1};
+    unless ($sha1_loaded) {
+        fatal(<<"EOM");
+Error loading the Perl module Digest::SHA1 needed for freedns update.
+On Debian, the package libdigest-sha1-perl must be installed.
+EOM
+    }
+    import  Digest::SHA1 (qw/sha1_hex/);
+}
+######################################################################
 ## geturl
 ######################################################################
 sub geturl {
@@ -1729,8 +1777,10 @@
     my ($sd, $rq, $request, $reply);
 
     debug("proxy  = $proxy");
-    debug("url    = $url");
+    debug("url    = %s", $url);
     ## canonify proxy and url
+    my $force_ssl;
+    $force_ssl = 1 if ($url =~ /^https:/);
     $proxy  =~ s%^https?://%%i;
     $url    =~ s%^https?://%%i;
     $server = $url;
@@ -1743,7 +1793,7 @@
     $globals{'fw'} && debug("glo fw = $globals{'fw'}"); 
     #if ( $globals{'ssl'} and $server ne $globals{'fw'} ) {
     ## always omit SSL for connections to local router
-    if ( $globals{'ssl'} and (caller(1))[3] ne 'main::get_ip' ) {
+    if ( $force_ssl || ($globals{'ssl'} and (caller(1))[3] ne 'main::get_ip') ) {
         $use_ssl      = 1;
         $default_port = 443;
 		load_ssl_support;
@@ -1769,7 +1819,7 @@
     $request .= "Host: $server\n";
 
     my $auth = encode_base64("${login}:${password}");
-    $request .= "Authorization: Basic $auth" if $login || $password;
+    $request .= "Authorization: Basic $auth\n" if $login || $password;
     $request .= "User-Agent: ${program}/${version}\n";
     $request .= "Connection: close\n";
     $request .= "\n";
@@ -1781,7 +1831,7 @@
     $0 = sprintf("%s - connecting to %s port %s", $program, $peer, $port);
     if (! opt('exec')) {
 	debug("skipped network connection");
-	verbose("SENDING:", $request);
+	verbose("SENDING:", "%s", $request);
     } elsif ($use_ssl) {
 	    $sd = IO::Socket::SSL->new(
             PeerAddr => $peer,
@@ -1802,39 +1852,39 @@
 	    defined $sd or warning("cannot connect to $peer:$port socket: $@");
     }
 
-    if (defined $sd) {
-	## send the request to the http server
-	verbose("CONNECTED: ", $use_ssl ? 'using SSL' : 'using HTTP');
-	verbose("SENDING:", $request);
+	if (defined $sd) {
+		## send the request to the http server
+		verbose("CONNECTED: ", $use_ssl ? 'using SSL' : 'using HTTP');
+		verbose("SENDING:", "%s", $request);
 
-    	$0 = sprintf("%s - sending to %s port %s", $program, $peer, $port);
-	my $result = syswrite $sd, $rq;
-	if ($result != length($rq)) {
-	    warning("cannot send to $peer:$port ($!).");
-	    
-	} else {
-	    my $timeout = 0;
-	    local $SIG{'ALRM'} = sub { $timeout = 1; };
+		$0 = sprintf("%s - sending to %s port %s", $program, $peer, $port);
+		my $result = syswrite $sd, $rq;
+		if ($result != length($rq)) {
+			warning("cannot send to $peer:$port ($!).");
+		} else {
+			$0 = sprintf("%s - reading from %s port %s", $program, $peer, $port);
+			eval {
+				local $SIG{'ALRM'} = sub { die "timeout";};
+				alarm(opt('timeout')) if opt('timeout') > 0;
+				while ($_ = <$sd>) {
+					$0 = sprintf("%s - read from %s port %s", $program, $peer, $port);
+					verbose("RECEIVE:", "%s", define($_, "<undefined>"));
+					$reply .= $_ if defined $_;
+				}
+				if (opt('timeout') > 0) {
+					alarm(0);
+				}
+			};
+			close($sd);
 
-    	    $0 = sprintf("%s - reading from %s port %s", $program, $peer, $port);
-	    alarm(opt('timeout')) if opt('timeout') > 0;
-	    while (!$timeout &&  ($_ = <$sd>)) {
-    	        $0 = sprintf("%s - read from %s port %s", $program, $peer, $port);
-		verbose("RECEIVE:", "%s", define($_, "<undefined>"));
-		$reply .= $_ if defined $_;
-	    }
-	    if (opt('timeout') > 0) {
-		alarm(0);
-	    }
-	    close($sd);
-	    if ($timeout) {
-		warning("TIMEOUT: %s after %s seconds", $to, opt('timeout'));
-		$reply = '';
-	    }
-	    $reply = '' if !defined $reply;
+			if ($@ and $@ =~ /timeout/) {
+				warning("TIMEOUT: %s after %s seconds", $to, opt('timeout'));
+				$reply = '';
+			}
+			$reply = '' if !defined $reply;
+		}
 	}
-    }
-    $0 = sprintf("%s - closed %s port %s", $program, $peer, $port);
+	$0 = sprintf("%s - closed %s port %s", $program, $peer, $port);
 
     ## during testing simulate reading the URL
     if (opt('test')) {
@@ -1855,28 +1905,29 @@
 ######################################################################
 sub get_ip {
     my $use = lc shift;
+    my $h = shift;
     my ($ip, $arg, $reply, $url, $skip) = (undef, opt($use), '');
     $arg = '' unless $arg;
 
     if ($use eq 'ip') {
-	$ip  = opt('ip');
+	$ip  = opt('ip', $h);
 	$arg = 'ip';
 
     } elsif ($use eq 'if') {
-	$skip  = opt('if-skip')  || '';
+	$skip  = opt('if-skip', $h)  || '';
 	$reply = `ifconfig $arg 2> /dev/null`;
 	$reply = '' if $?;
 
     } elsif ($use eq 'cmd') {
 	if ($arg) {
-	    $skip  = opt('cmd-skip')  || '';
+	    $skip  = opt('cmd-skip', $h)  || '';
 	    $reply = `$arg`;
 	    $reply = '' if $?;
 	}
 
     } elsif ($use eq 'web') {
-	$url  = opt('web')       || '';
-	$skip = opt('web-skip')  || '';
+	$url  = opt('web', $h)       || '';
+	$skip = opt('web-skip', $h)  || '';
 
 	if (exists $builtinweb{$url}) {
 	    $skip = $builtinweb{$url}->{'skip'} unless $skip;
@@ -1885,15 +1936,15 @@
 	$arg = $url;
 
 	if ($url) {
-	    $reply = geturl(opt('proxy'), $url) || '';
+	    $reply = geturl(opt('proxy', $h), $url) || '';
         }
 
     } elsif (($use eq 'cisco')) {
 	# Stuff added to support Cisco router ip http daemon
 	# User fw-login should only have level 1 access to prevent
 	# password theft.  This is pretty harmless.
-	my $queryif  = opt('if');
-	$skip = opt('fw-skip')  || '';
+	my $queryif  = opt('if', $h);
+	$skip = opt('fw-skip', $h)  || '';
 
 	# Convert slashes to protected value "\/"
 	$queryif =~ s%\/%\\\/%g;
@@ -1901,13 +1952,30 @@
 	# Protect special HTML characters (like '?')
 	$queryif =~ s/([\?&= ])/sprintf("%%%02x",ord($1))/ge;
 
-	$url   = "http://".opt('fw')."/level/1/exec/show/ip/interface/brief/${queryif}/CR";
-	$reply = geturl('', $url, opt('fw-login'), opt('fw-password')) || '';
+	$url   = "http://".opt('fw', $h)."/level/1/exec/show/ip/interface/brief/${queryif}/CR";
+	$reply = geturl('', $url, opt('fw-login', $h), opt('fw-password', $h)) || '';
 	$arg   = $url;
 
+    } elsif (($use eq 'cisco-asa')) {
+	# Stuff added to support Cisco ASA ip https daemon
+	# User fw-login should only have level 1 access to prevent
+	# password theft.  This is pretty harmless.
+	my $queryif  = opt('if', $h);
+	$skip = opt('fw-skip', $h)  || '';
+
+	# Convert slashes to protected value "\/"
+	$queryif =~ s%\/%\\\/%g;
+
+	# Protect special HTML characters (like '?')
+	$queryif =~ s/([\?&= ])/sprintf("%%%02x",ord($1))/ge;
+
+	$url   = "https://".opt('fw', $h)."/exec/show%20interface%20${queryif}";
+	$reply = geturl('', $url, opt('fw-login', $h), opt('fw-password', $h)) || '';
+	$arg   = $url;
+
     } else {
-	$url  = opt('fw')       || '';
-	$skip = opt('fw-skip')  || '';
+	$url  = opt('fw', $h)       || '';
+	$skip = opt('fw-skip', $h)  || '';
 
 	if (exists $builtinfw{$use}) {
 	    $skip = $builtinfw{$use}->{'skip'} unless $skip;
@@ -1916,7 +1984,7 @@
 	$arg = $url;
 
 	if ($url) {
-	    $reply = geturl('', $url, opt('fw-login'), opt('fw-password')) || '';
+	    $reply = geturl('', $url, opt('fw-login', $h), opt('fw-password', $h)) || '';
         }
     }
     if (!defined $reply) {
@@ -2270,6 +2338,7 @@
 Configuration variables applicable to the 'dyndns2' protocol are:
   protocol=dyndns2             ## 
   server=fqdn.of.service       ## defaults to members.dyndns.org
+  script=/path/to/script       ## defaults to /nic/update
   backupmx=no|yes              ## indicates that this host is the primary MX for the domain.
   static=no|yes                ## indicates that this host has a static IP address.
   custom=no|yes                ## indicates that this host is a 'custom' top-level domain name.
@@ -2318,7 +2387,9 @@
        '!yours'   => 'The hostname specified exists, but not under the username currently being used',
        '!donator' => 'The offline setting was set, when the user is not a donator',
        '!active'  => 'The hostname specified is in a Custom DNS domain which has not yet been activated.',
-       'abuse',   => 'The hostname specified is blocked for abuse; fill in the form at http://support.dyndns.org/abuse.php to be unblocked',
+       'abuse',   => 'The hostname specified is blocked for abuse; you should receive an email notification ' . 
+                     'which provides an unblock request link.  More info can be found on ' . 
+                     'https://www.dyndns.com/support/abuse.html',
 
        'numhost'  => 'System error: Too many or too few hosts found. Contact support@dyndns.org',
        'dnserr'   => 'System error: DNS error encountered. Contact support@dyndns.org',
@@ -2338,7 +2409,7 @@
 	verbose("UPDATE:","updating %s", $hosts);
 
 	## Select the DynDNS system to update
-	my $url = "http://$config{$h}{'server'}/nic/update?system=";
+	my $url = "http://$config{$h}{'server'}$config{$h}{'script'}?system=";
 	if ($config{$h}{'custom'}) {
 	    warning("updating %s: 'custom' and 'static' may not be used together. ('static' ignored)", $hosts)
 	      if $config{$h}{'static'};
@@ -2375,6 +2446,8 @@
 
 	my @reply = split /\n/, $reply;
 	my $state = 'header';
+	my $returnedip = $ip;
+
 	foreach my $line (@reply) {
 	    if ($state eq 'header') {
 		$state = 'body';
@@ -2385,7 +2458,10 @@
 	    } elsif ($state =~ /^results/) {
 		$state = 'results2';
 
-		my ($status, $ip) = split / /, lc $line;
+		# bug #10: some dyndns providers does not return the IP so
+		# we can't use the returned IP
+		my ($status, $returnedip) = split / /, lc $line;
+		$ip = $returnedip if (not $ip);
 		my $h = shift @hosts;
 	    
 		$config{$h}{'status'} = $status;
@@ -3378,7 +3454,98 @@
     }
 }
 
+###################################################################### 
+
+###################################################################### 
+## nic_freedns_examples 
+###################################################################### 
+sub nic_freedns_examples {
+return <<EoEXAMPLE;
+
+o 'freedns'
+
+The 'freedns' protocol is used by DNS services offered by freedns.afraid.org.
+
+Configuration variables applicable to the 'freedns' protocol are:
+  protocol=freedns             ##
+  server=fqdn.of.service       ## defaults to freedns.afraid.org
+  login=service-login          ## login name and password registered with the service
+  password=service-password    ##
+  fully.qualified.host         ## the host registered with the service.
+
+Example ${program}.conf file entries:
+  ## single host update
+  protocol=freedns,                                             \\
+  login=my-freedns.afraid.org-login,                            \\
+  password=my-freedns.afraid.org-password                       \\
+  myhost.afraid.com
+
+EoEXAMPLE
+} 
 ######################################################################
+## nic_freedns_update
+##
+## written by John Haney
+##
+## based on http://freedns.afraid.org/api/
+## needs this url to update:
+## http://freedns.afraid.org/api/?action=getdyndns&sha=<sha1sum of login|password>
+## This returns a list of host|currentIP|updateURL lines.
+## Pick the line that matches myhost, and fetch the URL.
+## word 'Updated' for success, 'fail' for failure.
+##
+######################################################################
+sub nic_freedns_update {
+
+
+    debug("\nnic_freedns_update -------------------");
+
+    ## First get the list of updatable hosts
+    my $url;
+    $url = "http://$config{$_[0]}{'server'}/api/?action=getdyndns&sha=".&sha1_hex("$config{$_[0]}{'login'}|$config{$_[0]}{'password'}");
+    my $reply = geturl(opt('proxy'), $url);
+    if (!defined($reply) || !$reply || !header_ok($_[0], $reply)) {
+        failed("updating %s: Could not connect to %s for site list.", $_[0], $url);
+	return;
+    }
+    my @lines = split("\n", $reply);
+    my %freedns_hosts;
+    grep {
+        my @rec = split(/\|/, $_);
+	$freedns_hosts{$rec[0]} = \@rec if ($#rec > 0);
+    } @lines;
+    if (!keys %freedns_hosts) {
+	failed("Could not get freedns update URLs from %s", $config{$_[0]}{'server'});
+	return;
+    }
+    ## update each configured host
+    foreach my $h (@_) {
+        if(!$h){ next };
+        my $ip = delete $config{$h}{'wantip'};
+	info("setting IP address to %s for %s", $ip, $h);
+	verbose("UPDATE:","updating %s", $h);
+
+	if($ip ne $freedns_hosts{$h}->[1]) {
+	    my $reply = geturl(opt('proxy'), $freedns_hosts{$h}->[2]);
+	    if (!defined($reply) || !$reply) {
+	        failed("updating %s: Could not connect to %s.", $h, $freedns_hosts{$h}->[2]);
+		last;
+	    }
+	    last if !header_ok($h, $reply);
+
+	    if($reply =~ /Updated.*host/) {
+	        success("updating %s: good: IP address set to %s", $h, $ip);
+	    } else {
+	        $config{$h}{'status'} = 'failed';
+		warning("SENT: %s", $freedns_hosts{$h}->[2]) unless opt('verbose');
+		warning("REPLIED: %s", $reply);
+		failed("updating %s: Invalid reply.", $h);
+	    }
+	}
+    }
+}
+
+######################################################################
 # vim: ai ts=4 sw=4 tw=78 :
 
 
Index: patches/loopia.patch
===================================================================
Index: patches/freedns-patch
===================================================================
Index: patches/prevent-hang.patch
===================================================================
Index: patches/cisco-asa.patch
===================================================================
Index: patches/foreground.patch
===================================================================
Index: README
===================================================================
--- README	(.../tags/release-3.8.0)
+++ README	(.../trunk)
@@ -27,6 +27,7 @@
 DnsPark     - See http://www.dnspark.com for details
 DslReports  - See http://www.dslreports.com for details
 Sitelutions - see http://www.sitelutions.com for details
+Loopia      - See http://www.loopia.se for details
 
 DDclient now supports many of cable/dsl broadband routers. 
 
Index: RELEASENOTE
===================================================================
--- RELEASENOTE	(.../tags/release-3.8.0)
+++ RELEASENOTE	(.../trunk)
@@ -0,0 +1,11 @@
+It's been a while but here is new release of ddclient. There are some important
+changes and some documentation is modified.  A detailed overview can be found
+in ChangeLog but here's a quick overview:
+
+	* Added ddclient-noip.patch send by Kurt Bussche.
+ 	* Added and applied default timeout patch from
+          https://bugs.launchpad.net/ubuntu/+source/ddclient/+bug/116066
+ 	* Sending mail when killed, not after TERM-signal
+	* Added support for multiple IP adresses.
+
+
Index: .cvsignore
===================================================================
